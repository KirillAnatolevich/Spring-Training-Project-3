# Практическая задача
**Условие**:
«На море на океане есть остров, на том острове дуб стоит, под дубом сундук зарыт, в сундуке — заяц, в зайце — утка, в утке — яйцо, в яйце — игла, — смерть Кощея»
Зависимости остались прежние. В упражнении появился компонент Кощей Бессмертный (KoscheiTheDeathless), который расскажет, где находится его смерть, если вызвать метод getRulesByDeth().
Для описания поиска смерти использованы классы в пакете models. Для вашего удобства они были пронумерованы: Ocean1, Island2, Wood3 и так далее.
Чтобы Спринг видел все бины, в классе AppConfig была добавлена аннотация @ComponentScan.
В Спринге связать бины можно различными способами, рассмотрим их на примере:

1)  KoscheiTheDeathless связывается с Ocean1 через сеттер setOcean и аннотации @Autowired над ней.
2)  Ocean1 связан с Island2 через поле и аннотацию, которая подтянет бин Island2 через метод getIsland() в классе AppConfig. Обратите внимание, что данный метод обозначен аннотацией @Bean, что автоматически подтягивает аргументы в метод. В качестве аргумента выступает бин Wood3.
3) Бин Wood3 помечен как компонент, который конструируется через связывание по @Autowired с помощью конструктора.
   Задание:
   Собрать цепочку до 8го элемента, использовав все вышеперечисленные методы связывания. После выполнения вы должны получить полную фразу. Проверьте своё решение тестом из заготовки.

## Теория.
1.  Что такое бин?
   * Это класс, который управляется spring
2.  Виды бинов?
   * Singleton
   * Prototype
   * Request, session, application - для веб приложений
   * WebSocket - связывание жизненным циклом WebSocket
3.  Чем бин отличается от POJO-класса? 
   * Тем, что он находится под 
4.  Что такое Inversion of Control и как Spring реализует этот принцип?
   * — это процесс, согласно которому объекты определяют свои зависимости, то есть объекты, с которыми они работают, через аргументы конструктора или фабричного метода или свойства, которые были установлены или возвращены фабричным методом. Затем контейнер внедряет эти зависимости при создании бина.

   В Spring Framework IoC-контейнер реализуется с помощью интерфейсов BeanFactory и ApplicationContext.

   Интерфейс BeanFactory предоставляет механизм конфигурации по управлению любым типом объектов. ApplicationContext наследует интерфейс BeanFactory и добавляет более специфичную функциональность.
5.  Для чего существует такое количество ApplicationContext?
   * (своими словами) Используется для того, что бы создавать иерархию контейнеров, так как каждый новый ApplicationContext, ни чего не знает о соседнем, если не добавлять в путь в конфигурации информацию о соседних контейнерах
6.  Как можно связать бины?
   * Через конструкторы, сеттеры, через @Autowired".
7.  Что такое Dependency Injection?
   * Предоставление зависимости программному компоненту
8.  Какие бины будут использоваться для настройки приложения?
   * (как я понял) Либо те, которые являются @Component итп, либо в @Configuration указаны как @Bean, и настроены между собой
